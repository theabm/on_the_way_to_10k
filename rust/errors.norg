
Error Handling

___

Rust classifies errors in two categories:
- recoverable errors: in this case we just want to try the operation again
- unrecoverable errors: a symptom of a bug. In this case, we want out code to 
  immediately stop.

Recoverable errors has the `Result<T,E>` enum while unrecoverable errors use the 
`panic!` macro that stops execution. 

First we talk about `panic!`.

* Unrecoverable Errors with `panic!`

  There are two ways to cause a panic: by taking an action that causes the code 
  to panic (such as accessing an array past the end) or by calling the `panic!`
  macro.

  By default panic will print a failure message, unwind, clean up the stack, 
  and quit. We can also set an evironment variable to display the call stack 
  when a panic occurs to make debugging easier.


** Unwinding the Stack or Aborting in Responde to a Panic
   By default, when panic occurs, the program starts to `unwind`, which means 
   Rust walks back up the stack and cleans up. This operation is a lot of work, 
   so you have the alternative of immediately aborting, which ends the program 
   without cleanup.

   In this case, all memory used by the program will need to be cleaned up by 
   the Operating System. If you need to make the binary as small as possible, 
   you can switch from unwinding to aborting upon a panic by adding `panic = 'abort'`
   to the appropriate [profile] section in Cargo.toml

   ---

  We show an example of using the `panic!` macro.
@code rust
  fn main() {
    panic!("crash and burn");
}
  @end
  If we run this program, we will see the error message "crash and burn" and 
  the place in the source code where panic ocurred: `src/main.rs:2:5`, which 
  indicates that it's line 2, 5th character in `src/main.rs`.

  In this case, the line indicates is part of our code. However, in other cases, 
  the `panic!` call might be in code that our code calls, so the filename and 
  line number will be someone else's code where `panic!` is called, not the 
  line of our code that eventually led to the panic. We can use the backtrace 
  of the functions the `panic!` call came from to figure out the part of our code 
  that is causing the problem.

  For example, the following code will panic, but not from an explicit call to
  `panic!` in our code.
@code rust
  fn main() {
    let v = vec![1, 2, 3];
    // trying to access an element out of range
    v[99];
}
  @end

  If we try to run this, we will not see the line of *our* code that causes 
  the issue. To do this, we need to set the environment variable `RUST_BACKTRACE=1`
  by running `RUST_BACKTRACE=1 cargo run`.

  This will show the entire stack call, and we have to follow it from the top 
  downwards until we arrive at a file we have written. In our case, we eventually 
  find `src/main.rs:4:5` which tells us that the 4th line called code that 
  caused a panic. 

* Recoverable Errors with Result
  Most errors aren't serious enough that we should call `panic!` to stop execution.
  Rather, we want to be able to recover from these cases. 

  This can be done throughthe `Result` enum which is defined as having the `Ok`
  and the `Error` variants:
@code rust
  enum Result<T, E> {
    Ok(T),
    Err(E),
}
  @end
  The `T` represents the type of value that will be returned in a success case 
  within `Ok` and `E` represents the type of error returned in a failure case 
  within the `Err` variant.

  We can use a match expression to handle the success and failure case, as shown 
  below:
@code rust
  use std::fs::File;

fn main() {
      // returns a Result<std::fs::File, std::io::Error>
    let greeting_file_result = File::open("hello.txt");

    // we do a match on the result and deconstruct the variants
    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => panic!("Problem opening the file: {:?}", error),
    };
  }
  @end

  In this case, if the operation is successful, we will extract the file handle 
  from the `Ok` variant and assign it to `greeting_file`, otherwise, we have 
  chosen to handle the error case by calling `panic!` (however, we could have done 
  something else. The key is that we can recover from this error in any way we 
  want!).

  If we want to take different actions based on the type of the error, then we 
  can use another inner match expression:
@code rust
  use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => match error.kind() {
              // if the error is that the file was not found, 
              // we create it and then return the handle to it.
              // if the creation fails, we panic.
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
              // for any other type of error(maybe we lack 
              // permissions to read), we panic.
            other_error => {
                panic!("Problem opening the file: {:?}", other_error);
            }
        },
    };
  }
  @end

  Note that `File::open` returns an `io::Error` inside the `Err` variant.
  This type is a struct which has a `kind` method we can call that 
  returns an enum `io::ErrorKind`. The variants of this enum represent the 
  different kinds of errors that might result from an `io` operation.

  We want to use the `ErrorKind::NotFound` variant which indicates that 
  the file does not exist. In this case, we try to create the file and again, 
  we must use a match to check if the creation was successful. In all cases of 
  failure, we just `panic!`.

  As a side note, later we will see closures, which can simplify a lot of code 
  and eliminate a lot of these match expressions. 
  For example, here is a snippet that would achieve the same results as the one 
  above while being shorter and cleaner.
@code rust
  use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {:?}", error);
            })
        } else {
            panic!("Problem opening the file: {:?}", error);
        }
    });
  }
  @end

* Shortcuts for Panic on Error: `unwrap` and `expect`











* To `panic!` or Not to `panic!`


