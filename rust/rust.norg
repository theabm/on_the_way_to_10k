* Introduction

** Installing 

   To install rust, run the following
   @code bash
   curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf \| sh
   @end

   You will also need to install a `Linker` to join compiled outputs into one. 
   The most common linker is the one you get when you install gcc or clang.

   Once rust is installed, to update it you can run:

   @code bash 
   rustup update
   @end


** Hello world 

   Open a file called hello_world.rs and write the following: 

   @code rust 
   // the main function is declared like this (with no parameters)
   // in rust we place the curly bracket in the same line as the 
   // function declaration
   //
   // To use rust formatting use rustfmt
   fn main() {
       // this prints text to screen. Note:
       // 1. we use indent
       // 2. println! calls a rust macro. Functions dont have !
       // 3. we pass string "Hello, world!"
       // 4. lines are ended with semicolon
       println!("Hello, world!");
   }

   @end

   To compile and run: 
   @code bash
   rustc hello_world.rs
   ./hello_world

   @end

** Using Cargo

   Cargo is Rust's build system and package manager. It is used to manage 
   Rust projects since it:
   - builds your code 
   - downloads libraries your code depends on - a.k.a dependencies
   - building these libraries

   Furthermore, Cargo comes preinstalled with rust if you use official installers.

   Check your version by running: 
   @code bash
   cargo --version
   @end 

*** Creating new cargo project

    To create a new project using cargo, simply run:

    @code bash 
    cargo new hello_cargo 
    @end
    This will create an initialized git repository named
    `hello_cargo` where you will find the following structure:
    - Cargo.toml
    - src directory
    -- main.rs 
    - .git 
    - .gitignore


* Common Programming Concepts 

  In this section we cover some basic programming concepts and describe them 
  in the context of Rust. We will see:
  - variables 
  - basic types 
  - functions 
  - comments 
  - control flow 

** Variables and mutability 

   By default variables are immutable. This is one of the main design choices 
   of rust to encourage safety and easy concurrency.

   However, variables can still be made to be mutable.
   Consider the following example:
   @code rust
   fn main() {
       let x = 5;  
       println!("The value of x is: {x}");
       x = 6; 
       println!("The value of x is: {x}");
   }
   @end
   This code does not compile and we get an immutability error.

   Immutability is helpful because it prevents bugs that occur when we operate 
   under the assumption that variables are constant but in reality get changed 
   throughout the code. 

   However, mutability is necessary in an imperative paradigm.  
   To make a variable mutable, add the `mut` keyword.

   @code rust
   fn main() {
       let mut x = 5;  
       println!("The value of x is: {x}");
       x = 6; 
       println!("The value of x is: {x}");
   }
   @end

   This code now compiles.

   One last subtlety: Rust does not require a variable declared only with 
   `let` to be initialized as long as it is assigned only once. Therefore, 
   this is allowed:

   @code rust
   fn main() {
       let x;  
       x = 6; 
       println!("The value of x is: {x}");
   }
   @end

*** Constant variables

    We can create constant variables with the `const` keyword instead of `let`. 
    They are different from immutable variables in the following: 
    - const variables cannot be used with `mut`
    - const variables must always be type annotated.
    - const variables must *_always_* be known at compile time. 
      On the other hand, immutable variables can be known at run-time. 

    Some useful facts about constants:

    ~ The naming convention is MY_CONST_VARIABLE_NAME.
    ~ The operations we can use for const expressions are limited by the 
      compiler.
    ~ Constants are valid throughout the entire run-time of the code and exist 
      within the scope in which they are declared. 
    ~ They can be used in the global scope (outside of a function) while `let`
      can only be used in a function. 

*** Shadowing 

    In Rust we can redeclare variables with the same name and different type. 
    This is called variable *_shadowing_* since the compiler only sees the second 
    variable until its shadowed again or the scope ends.

    An example:
    @code rust 
    fn main() {
        // first variable name
        let x = 5;

        // the variable is shadowed
        let x = x + 1;
        // from this point, x=6

        {
            // variable is shadowed again, x=12
            let x = x * 2;
            println!("The value of x in the inner scope is: {x}");
        } // after scope ends, shadow goes out of scope and we see old 
        // variable once again, i.e x=6

        println!("The value of x is: {x}");
    }
    @end

    - Shadowing is different from marking a variable as `mut` because it allows 
      us to perfom some transformations and then have that variable be 
      immutable for the rest of the code. 
      On the other hand, a `mut` variable can always be changed (even though 
      we may not want it to).

    - The other difference is that since we are effectively creating a new 
      variable, we can change its type. This can't be done if we just mark a 
      variable as `mut` and then try to assign to it a different type without 
      using the `let` keyword to overshadow.

    - A subtle note: when shadowing we can also change the mutability of a the 
      variable.

    This code compiles:
    @code rust 
    // spaces is a string 
    let spaces = "   "; 
    // spaces is now a number
    let spaces = spaces.len();
    @end 
    Note that shadowing can work together with `mut`. The key is using `let` 
    twice.

    This code does not compile:
    @code rust
    // spaces is a string 
    let mut spaces = "   ";
    // here we try to assign an int to spaces 
    // which is declared as a string since 
    // its the same variable.
    spaces = spaces.len();
    @end

** Data Types

   Rust is a statically typed language - the type of all variables must be known 
   at compile time. 
   The compiler can usually infer the type. 
   If there are multiple possibilities, we need to use type annotations.

   @code rust 
   // type annotation with `:` 
   let my_var : u32 = 100;
   @end

*** Scalar Types 

    A `scalar` type represents a single value. 
    Rust has four primary scalar types: 
    - integers 
    - floating point numbers 
    - booleans 
    - charachters
**** Integers
     A whole number. The possible variants are: 8 bit, 16 bit, 32 bit, 64 bit, 128 
     bit - all signed (i) or unsigned (u). So an unsigned 8 bit int is written as 
     u8. 
     There is also an architecture dependent int `arch` which can be isize or 
     usize. This will be 64 bits if using 64 bit machine or 32 bit for 32 bit 
     machine. 
     *_Literals_*
     ~ Decimals: can use `_` separator `98_222`
     ~ Hex: `0xff`
     ~ Binary: can use `_` separator `0b1111_0000`
     ~ Byte (u8 only): `b'A'`

     Rust default is i32, which is usually more than enough.

***** Integer overflow

      When compiling in `debug` mode Rust includes checks for integer 
      overflow which cause the code to *_panic_* at runtime if this 
      behavior occurs. Rust uses the term /panicking/ when a program 
      exits with an error. 

      When compiling in `release` mode, rust does *not* include checks 
      for overflow that cause panic. Instead, if overflow occurs, it wil 
      do two's complement wrapping. So for u8, a value of 256 is mapped to 0, 
      257 is mapped to 1, etc.
      Relying on this behaviour is considered an error.

      To explicitly handle the possibility of overflow, you can use these 
      families of methods provided by the standard library for primitive numeric
      types:

      - Wrap in all modes with the wrapping_* methods, such as wrapping_add.
      - Return the None value if there is overflow with the checked_* methods.
      - Return the value and a boolean indicating whether there was overflow 
        with the overflowing_* methods.
      - Saturate at the valueâ€™s minimum or maximum values with the 
        saturating_* methods.

**** Floating point types

     Rust has two primitive types for floating point numbers, namely `f32` and 
     `f64`. 

     The default is `f64` (double precision) since on most modern machines it is 
     just as fast and allows greater precision.

**** Boolean type

     In Rust, Booleans have two possible values: `true` and `false`.

     They are one byte long. 

     It is specified using the type `bool`.

**** Character type

     Declared using `char`. 

     `char` and `string` literals are specified with single and double 
     quotes, respectively.
     A `char` is 4 bytes long and represents a Unicode Scalar Value, 
     which can encode more than ASCII.


*** Compound Types

    Compound types group multiple values of possibly multiple types together 
    to form a new type. 

**** Tuple Type

     A tuple groups many possibly different types together. They have a fixed 
     length that must be known at compile time. 

     They are created by writing a comma separated list of values inside 
     parenthesis. 

     @code rust
     fn main() {
         // a triple of int32, float 64, and unsigned int 8
         let tup: (i32, f64, u8) = (500, 6.4, 1);
     }
     @end

     Note that the tuple type is determined by both the length of the tuple 
     as well as the types of the elemnts inside it (and the order). 

     This is similar to what happens in Haskell.

     To get individual items of a tuple, we can use pattern matching:
     @code rust
     fn main() {
         let tup = (500, 6.4, 1);

         let (x, y, z) = tup;

         println!("The value of y is: {y}");
     }
     @end
     This is called /tuple destructuring/.

     Alternatively, we can use the `.` operator with the index position 
     of the element:

     @code rust 
     fn main() {
         let x: (i32, f64, u8) = (500, 6.4, 1);

         let five_hundred = x.0;

         let six_point_four = x.1;

         let one = x.2;
     }
     @end

     A tuple with no values is called a /unit/. It is written as `()` 
     and represents an empty value or empty return type. 

     Expressions implicitly return a unit if they dont return 
     anything else.


**** The Array Type
     Contrary to a tuple, the elements of an array must be of the same 
     type. 
     Unlike arrays in other languages, arrays in Rust have a fixed length.

     They are written as comma separated values within square brackets:
     @code rust 
     fn main() {
         // array with type annotation
         let a:[u8; 5] = [1, 2, 3, 4, 5];
         // array initialization with repetition
         // this is the same as let b = [3,3,3,3,3];
         let b = [3; 5];
     }
     @end

     Arrays are useful if you want to allocate in the stack rather than 
     the heap. 

     On the other hand, if we want an array that is allocated in the heap which
     can dynamically grow and shrink, we must use the `vector` type, which is 
     provided by the standard library. 

     These concepts are similar to static and dynamic arrays in C and C++.

     To access an element in the array, we can use indexes. 
     @code rust
     fn main() {
         let a = [1, 2, 3, 4, 5];

         let first = a[0];
         let second = a[1];
     }
     @end

***** Bound checking

      What happens if we try to access an index of the array that is 
      out of bounds? 

      For example suppose we have an array of length 4, and we ask the 
      user to insert an index.

      For 0 to 3, the code will run fine, but if we insert 4 or greater, 
      the code will _panic_. 

      In other words, Rust inserts run-time checks to make sure we don't 
      access out of bound elements. 

      These checks cannot be done only at compile time since we cannot know 
      what the user will try to enter. 

      This is one example of Rust's memory safety since in other languages, we 
      could access the out of bound index and get undefined behavior.
      Rust protects you against this by panicking and exiting the code immediately 
      rather than allowing this to happen.

** Functions

   Rust uses snake case for functions and variable names.

   We have seen `fn` to declare functions. 

   Rust doesn't care where we define functions, as long as they are defined 
   somewhere in a visible scope to the caller.

   Functions can have `parameters` that take on concrete values which are 
   called `arguments`.

   We _must_ declare the type of each parameter in a function signature. 

** Statements and Expressions

   - *_Statements_*: are instructions that perform some action and do not return 
     a value.
   - *_Expressions_*: evaluate to a resultant value. 

   @code rust
   // function definitions are also statements
   fn main() {
       // a statement
       let y = 6;
   }
   @end
   In the example above, the `let y = 6` statement does not retun a value. 
   So we cannot do something like `let x = (let y = 6)` since the last 
   `let` statement does not return a value so `x` cannot bind to anything. 
   This can be done in a language like C with `x=y=6`, since assignments 
   return a value. 
   Function *definitions* are also statements! Because we are just stating 
   that the function is doing something. 

   On the other hand, expressions evaluate to some value. And we can 
   mix statements and expressions! The `6` in `let y = 6` is an expression
   that evaluates to `6`. *Calling* a function is an expression since 
   functions in result _always_ return a value. Calling a macro is an 
   expression as well.

   New scope blocks are expressions:
   @code rust 
   fn main() {
       let y = {
           // this scope block evaluates to 4 so 
           // y is bound to this value.
           let x = 3;
           x + 1
           // notice that there is no semicolon 

           // expressions do not include semicolons. 
           // if we put a semicolon, we turn it into a 
           // statement.

       };

       println!("The value of y is: {y}");
   }
   @end

** Functions with Return Values

   Rust functions can return a values to the caller. We always need 
   to declare the type of the returned value with an arrow `->`.

   The return value in a function can be: 
   - explicit with the `return` statement 
   - _implicit by returning the evaluation of the last expression in the function body_.

   The latter is most common in Rust.

   Note that functions that do not explicitly return anything or have an 
   expression inside the body still implicitly return a `unit`.

** Control Flow

   We briefly discuss the control flow constructs available in Rust: 
   `if`, `loop`, `while`, `for`.

*** `if` Expressions

    The first important detail to notice is that in Rust an `if` is 
    an *expression*. This means we can use it to return a value and bind 
    it to another variable. 

    `if` expressions allow to change the execution of a program based 
    on a boolean condition. Rust does not implicitly convert non-boolean 
    types to booleans, as C does for example. So we *must* have a 
    boolean condition. 

    The syntax is as usual:

    @code rust
    fn main() {
        let number = 6;

        if number % 4 == 0 {
            println!("number is divisible by 4");
        } else if number % 3 == 0 {
            println!("number is divisible by 3");
        } else if number % 2 == 0 {
            println!("number is divisible by 2");
        } else {
            println!("number is not divisible by 4, 3, or 2");
        }
    }
    @end

    However, we can use it as an expression inside a `let` statement: 

    @code rust
    fn main() {
        let condition = true;
        // note that since there are no semicolons inside the block 
        // of code, we implicitly return the last expression, which
        // is the number
        let number = if condition { 5 } else { 6 };

        println!("The value of number is: {number}");
    }
    @end

    Note that the returned values from both branches of the 
    `if` expression must be of the same type since Rust must know 
    the type of each variable at compile time. If they were of different 
    types, the compiler cannot infer the type. 

    Also, if we want to use `if` as an expression, we *need* to include 
    an `else` block so that the compiler knows what to do in both cases. 

*** `loop` Expressions

    The `loop` keyword executes a block of code indefinitely until you 
    stop it explicitly with the `break` keyword.

    We can also use `continue` to skip the rest of the code block for 
    the current iteration and start the next iteration.

    Since `loop` is an expression, we can use it to return a value. 

    We can do this by writing the value we wish to return after the 
    `break` keyword as follows:

    @code rust 
    fn main() {
        let mut counter = 0;

        let result = loop {
            counter += 1;

            if counter == 10 {
                break counter * 2;
            }
        };

        println!("The result is {result}");
    }
    @end

    Since, by default, the `break` and `continue` keywords apply to 
    the innermost loop, we can label nested loops and use the 
    labels to specify which loop - innermost or outermost - 
    we want to `break` or `continue`. 

    @code rust 
    fn main() {
        let mut count = 0;
        // label for outermost loop
        'counting_up: loop {
            let mut remaining = 10;

            loop {
                if remaining == 9 {
                    break;
                }
                if count == 2 {
                    // breaking outermost loop using 
                    // label
                    break 'counting_up;
                }
                remaining -= 1;
            }

            count += 1;
        }
    }
    @end

*** `while` Statements

    If we want to execute a code block while some condition holds true, 
    we can use a `while` loop. 
    For example:
    @code rust 
    fn main() {
        let mut number = 3;

        while number != 0 {
            println!("{number}!");

            number -= 1;
        }

        println!("LIFTOFF!!!");
    }
    @end

    *Note*: If you are anything like me, you may be wondering what 
    is the difference between `loop` and `while true`. The answer
    I have found so far is that since loop is guaranteed to run 
    at /least/ once, the compiler can make different assumptions. 

    For example, this is ok since we know the loop will execute 
    once at least:

    @code rust 
    let x;
    loop { x = 1; break; }
    println!("{}", x)
    @end 

    However, this is not valide for the compiler: 
    @code rust 
    let x;
    while true { x = 1; break; }
    println!("{}", x);
    @end

    The behaviour could be made to be the same if the compiler 
    would treat `while true` as a special case. However, this 
    adds a lot of complexity which can also introduce some 
    other bugs.     
    On the other hand, if you use `loop` you *tell* the compiler 
    this block will execute at least once, which is more elegant.

    Furthermore, a `loop` is an *expression* which can return a 
    value through `break` and a `while` is a *statement*.

*** `for` Statement

    Rust has a `for` keyword to loop through elements of a collection in 
    a very pythonic way: 

    @code rust 
    fn main() {
        let a = [10, 20, 30, 40, 50];

        for element in a {
            println!("the value is: {element}");
        }
    }
    @end

    This is much more safe and elegant than using a `while` statement with 
    a condition on the index of the array.


* Understanding Ownership 

  Ownership is a discipline for ensuring the safety of Rust programs. 

  What is safety? 
  - The absence of undefined behavior

  The primary goal of Rust is to ensure that programs never have undefined 
  behavior. 
  A secondary goal is to prevent undefined behavior at /compile-time/ rather 
  that at /run-time/. The purpose of this is twofold: 
  - Catching bugs at compile-time means avoiding them in production, improving 
    the reliability of your software. 
  - Catching bugs at compile-time means fewer run-time checks which improve the 
    performance of the code.

  Since ownership is about safety and safety is about preventing undefined 
  behavior, we need to understand ownership in the context of preventing 
  undefined behavior. 

  We concentrate on one type of undefined behavior: operations on memory. 

  Rust does not think about memory as an array of bytes, and it provides 
  a very particular way to think about memory. Ownership is a
  discipline to safely handle memory in this way of thinking.

** Rust model of memory

   Local variables live in _stack frames_. As we know, the stack grows downwards,
   towards lower addresses. Once a function goes out of scope, its associated 
   stack frame is *freed/dropped/deallocated*.

   Since the stack is reserved for small local variables, if we need to 
   deal with larger variables, we use the _heap_. Rust uses pointers 
   which point to memory regions in the heap.

   _Rust provides a construct called `Box` for putting data on the heap._

   When we copy boxes (i.e. data in the heap), we only copy the pointer. 
   In other words: 
   @code rust
   // we allocate an array of zeros of length 1 million in the heap
   // a is a pointer to that memory region.
   let a = Box::new([0; 1_000_000]);
   // We copy the address! Not the whole array. This corresponds to a 
   // shallow copy. 
   let b = a;

   // So throughout this program, we only have one array of 1 million 
   // elements.
   @end

   In the above example, at the end of the program, we cannot access the 
   array through `a` because it has been _moved_ - as we will explain 
   shortly.

   *_Rust does not allow manual memory management_*. Stack frames are 
   automatically managed by Rust. When a function goes out of scope, 
   Rust deallocates the stack frame immediately. 

   But what about the heap? Imagine if Rust had a `free()` function 
   that allowed manual deallocation. This manual memory management 
   can easily lead to bugs, for example, we could try to read a pointer 
   to a region that has been freed, or we could try to free a memory 
   region more than once.

   To avoid this, Rust does not allow manual memory deallocation. 

   Instead, Rust /automatically/ frees a box's heap memory. 

   $ Box deallocation principle (almost correct)
   If a variable is bound to a box, when Rust deallocates the 
   variable's stack frame, then Rust deallocates the box's heap 
   memory.

   This is almost correct. However, what happens if more than one 
   variable is bound to a box as the previous code snippet? In this 
   case, with the /almost/ correct principle, we would try to free 
   memory twice, which is also undefined behavior.

   To avoid this, we arrive at _*ownership*_. 

** What is Ownership?

   When we write:
   @code rust 
   let a = Box::new([0;1_000_000]);
   @end

   We say that `a` *_owns_* the box. Then, the statement `let b = a;` 
   *_moves_* ownership from `a` to `b`. 

   With these concepts, the fully correct version is: 

   $ Box deallocation principle (fully correct)
   If a variable owns a box, when Rust deallocates the variable's 
   stack frame, then Rust deallocates the box's heap memory. 

   Let's look at an example:

   @code rust
   fn main() {
       // first owns the heap that is allocated for the string
       let first = String::from("Ferris");
       // calling add_suffix
       let full = add_suffix(first);
       // after calling the add suffix, we pass ownership to full 
       // and then the stack of add suffix is deallocated.
        
       println!("{full}");
   }

   fn add_suffix(mut name: String) -> String {
       // here ownership has been moved from first to name

       // this function allocates a new box, copies old contents, 
       // adds the "jr" and then deallocates old box. So now, 
       // first points to invalid memory, while name owns the new 
       // mem region.
       name.push_str(" Jr.");

       name
   }
   @end

   What happens if we try to access `first` after it points to invalid 
   memory? Undefined behavior!

   To avoid this, rust imposes another rule:

   $ Moved heap data principle
   If a variable x moves ownership of heap data to another variable 
   y, then x cannot be used after the move.

   So we cannot use `first` after it has been moved! 
   If we tried doing it, we would get an error saying that we try to 
   *borrow* a value after it has been moved. 

   If we wanted to avoid moving data, we could *clone* it using the 
   `.clone()` method.

   @code rust
   fn main() {
       let first = String::from("Ferris");
       // this does a deep copy of first
       let first_clone = first.clone();
       // so now, we have two copies in heap of the same string

       // after the call to add_suffix on first_clone, 
       // first_clone will point to invalid data (as first did in 
       // the previous example). However, first is unchanged and 
       // safe to use
       let full = add_suffix(first_clone);
       println!("{full}, originally {first}");
   }

   fn add_suffix(mut name: String) -> String {
       name.push_str(" Jr.");
       name
   }
   @end

   In summary, ownership is primarily a discipline of heap management. More 
   generally, it is about _pointer management_, which we will see when we
   discuss how to create pointers in places other than the heap.
   The main ideas of ownership so far are:

   - All heap data must be owned by exactly one variable.
   - Rust deallocates heap data once its owner goes out of scope.
   - Ownership can be transferred by moves, which happen on assignments
     and function calls.
   - Heap data can only be accessed through its current owner, not a 
     previous owner.

** References and Borrowing

   Ownership, boxes, and moves provide a way to safely program 
   with the heap. However, move-only APIs can be inconvenient to use. 
   For example, suppose we want to read a string twice:
   @code rust 
   fn main() {
       let m1 = String::from("Hello");
       let m2 = String::from("world");
       greet(m1, m2);
       let s = format!("{} {}", m1, m2); // Error: m1 and m2 are moved
   }

   fn greet(g1: String, g2: String) {
       println!("{} {}!", g1, g2);
   }
   @end

   We could return ownership back to the main stack by returning a tuple, 
   however, this makes the code quite verbose. 

   Rust provides a way to achieve this. 

*** References are Non-Owning Pointers

    References allow us to /borrow/ values by creating non-owning references 
    to it. 
    Below we can see an example program that reads the strings twice using 
    references: 

    @code rust 
    fn main() {
        let m1 = String::from("Hello");
        let m2 = String::from("world");
        // note the ampersands to create a reference
        greet(&m1, &m2); 
        let s = format!("{} {}", m1, m2);
    }
    // note the ampersands to create a reference
    fn greet(g1: &String, g2: &String) { 
        println!("{} {}!", g1, g2);
    }
    @end 

    In this example we use references, which are created with `&`. 
    By writing `&m1` we are passing a reference to `m1` into the 
    function `greet` which we call `g1`. 

    Therefore, `g1` is a reference that points to `m1`. To go from
    `g1` to the memory in heap we need to do two jumps, one from 
    `g1` to `m1` and then from `m1` to the heap string.

    Note that `m1` owns the heap data `Hello`, while `g1` does not 
    own either `m1` or `Hello`. So after `greet` ends, no heap data 
    is dropped and only the stack frame for `greet` disappears.

*** Dereferencing a Pointer Accesses its Data

    In Rust, we use the *dereference* operator to "follow" pointers. 
    Below we have a few examples of dereferencing. 
    Note the difference between `r1` and `r2`. 
    @code rust
    let mut x: Box<i32> = Box::new(1);
    let a: i32 = *x;         // *x reads the heap value, so a = 1
    *x += 1;                 // *x on the left-side modifies the heap value,
                             //     so x points to the value 2

    let r1: &Box<i32> = &x;  // r1 points to x on the stack
    let b: i32 = **r1;       // two dereferences get us to the heap value

    let r2: &i32 = &*x;      // r2 points to the heap value directly
    let c: i32 = *r2;
    @end

    However, we rarely see the dereference operator in Rust programs. 
    This is because Rust implicitly inserts dereferences and references 
    in certain cases, such as calling a method with the dot operator. 
    In this way, our code is cleaner. 

    @code rust 
    let x: Box<i32> = Box::new(-1);
    let x_abs1 = i32::abs(*x); // explicit dereference
    let x_abs2 = x.abs();      // implicit dereference
    assert_eq!(x_abs1, x_abs2);

    let r: &Box<i32> = &x;
    let r_abs1 = i32::abs(**r); // explicit dereference (twice)
    let r_abs2 = r.abs();       // implicit dereference (twice)
    assert_eq!(r_abs1, r_abs2);

    let s = String::from("Hello");
    // note that in this case, we need a reference because 
    // otherwise ownership is moved to the function and 
    // we cannot access s anymore. 
    let s_len1 = str::len(&s); // explicit reference
    let s_len2 = s.len();      // implicit reference
    assert_eq!(s_len1, s_len2);
    @end

*** Rust Avoids Simultaneous Aliasing and Mutation

    Pointers allow *aliasing*: when two variables point to the same memory 
    region. When aliasing is combined with *mutation*, we have a recipe 
    for disaster: 
    - Deallocating the aliased data, leaving the other one to point to 
      freed memory. 
    - Mutating the aliased data, invalidating runtime properties expected 
      of the other variable.
    - Concurrently mutating the aliased data, causing a race condition.

    The example we analyze uses the vector data structure `Vec` which 
    is an array that can dynamically grow in size. This is done with 
    the `Vec::push` method, which can dynamically reallocate the array 
    to fit more elements if we exceed the *capacity* of the vector.

    Suppose that we try to do the following: 
    @code rust 
    let mut v: Vec<i32> = vec![1, 2, 3];
    let num: &i32 = &v[2];
    v.push(4);
    println!("Third element is {}", *num);
    @end

    By doing `v.push(4)`, the array could be dynamically reallocated to 
    enlarge its capacity. However, this means that the reference `num`
    is left pointing to invalid data. This is unsafe. 

    The origin of this unsafety is that we are both *aliasing*
    the vector (through the reference `num`) as well as *mutating* 
    it (through the `v.push(4)` operation). 

    To avoid these kinds of issues, Rust follows a basic principle: 

    $ Pointer Safety Principle
    Data should never be aliased and mutated at the same time

    Rust enforces this principle for owned pointers by disallowing
    aliasing since assigning a box from one variable to another 
    will move ownership, invalidating the use of the previous variable.

    However, since references by design create temporary aliases and 
    are non-owning pointers, they need to be treated 
    differently to ensure the /Pointer Safety Principle/.
    This is done through the *_borrow checker_*.

*** The Borrow Checker
    The main idea behind the borrow checker is that variables have 
    three kinds of *permissions* on their data. 
    - *Read(R)*: data can be copied to another location. 
    - *Write(W)*: data can be mutated in-place. 
    - *Own(O)*: data can be moved or dropped.

    These permissions don't exist at runtime, only within the compiler. 
    They describe how the compiler *thinks* about your program before 
    it is executed. 

    By default, a variable has R/O permissions on its data. 
    If it is annotated with `mut` it also has W permission. 

    The key idea is that
    *_references can temporarily remove these permissions_*

    Lets look at a safe example of the previous snippet:
    @code rust
    fn main() {
        let mut v: Vec<i32> = vec![1, 2, 3];
        let num: &i32 = &v[2];
        println!("Third element is {}", *num);
        v.push(4);
    }
    @end

    ~ After `let mut v = (...)`, the variable `v` has been initialized. 
      It gains *RWO* permissions
    ~ After `let num = &v[2]`, the data in `v` has been *borrowed* by `num` 
      Three things happen:
        ~~ The borrow removes *WO* permissions from `v`. `v` cannot be written 
           or owned, but can still be read. This also means we can't pass 
           ownership of `v` to another variable. 
        ~~ The variable `num` has gained *RO* permissions. `num` is not 
           writable (it is missing W permissions) because it was 
           not marked `let mut`.
        ~~ The path `\*num` has gained the *R* permission.
    ~ After `println!(...)`, then `num` is no longer in use, so `v` 
      is no longer borrowed. Therefore:
        ~~ `v` regains its *WO* permissions.
        ~~ `num` and `\*num` have lost all of their permissions 
    ~ After `v.push(4)`, then `v` is no longer in use, and it loses all
      of its permissions.

    Why do we see `num` and `\*num`? Because it's different to access 
    data through a reference, versus to manipulate the reference 
    itself. 
    Let's look at the following example that showcases this:
    @code rust 
    fn main() {
        let x = 0;
        let mut x_ref = &x;
        println!("{x_ref} {x}");
    }
    @end
    `x_ref` has the *W* permission, while `\*x_ref` does not. This 
    means we can assign `x_ref` to a different reference, i.e. 
    `x_ref = &y` but we cannot mutate the pointed data, i.e 
    `\*x_ref += 1`.

    More generally, _permissions are defined on *paths*_ and not 
    just variables. Paths are anything you can put on the left 
    side of an assignment. 
    They can be: 
    - Variables, like `a`.
    - Dereferences of paths, like `\*a`.
    - Fields of paths, like `a.0` for tuples or `a.field` for 
      structs (discussed later).
    - Any combination of the above.

*** The Borrow Checker Finds Permission Violations

    By the /Pointer Safety Principle/ data should not be aliased 
    and mutated at the same time. 
    The goal of these permissions is to ensure that this doesn't 
    happen. 

    Rust uses the *_borrow checker_* to check for potentially unsafe 
    operations involving references. Any time a path is used, Rust 
    checks that it has the appropriate permissions for the operation 
    that needs to be done. 
    Lets look at the unsafe snippet:
    @code rust 
    fn main() {
        let mut v: Vec<i32> = vec![1, 2, 3];
        let num: &i32 = &v[2];
        v.push(4);
        println!("Third element is {}", *num);
    }
    @end
    For example, the borrow `&v[2]` requires `v` to have *R* permissions.
    `v.push(4)` requires `v` to have *RW* permissions since it needs 
    to read and possibly reallocate data to enlarge the capacity. 
    However, in this case, `v` does not have *W* permissions, since 
    it has been borrowed. Therefore, Rust will not compile this code 
    and we will see an error related to immutable borrowing. 

     


















* Using Structs to Structure Related Data
* Enums and Pattern Matching 
* Managing Growing Projects with Packages, Crates, and Modules
* Common Collections
* Error Handling 
* Generic Types, Traits, and Lifetimes
* Writing Automated Tests
* I/0 
* Functional Language Features: Iterators and Closures
* More about Cargo and Crates.io 
* Smart Pointers
* Concurrency 
* Object Oriented Programming in Rust 
* Patterns and Matching
* Advanced Features: Unsafe Rust, Advanced Traits, Types, Functions, Closures, and Macros










