When you write larget programs, organizing code becomes important. 

It is convenient to group code with related functionality to clarify 
what part of the code implements a certain feature.

In this section we cover Rust's /module system/: 
~ Packages: A Cargo Feature that lets you build, test, and share 
  crates.
~ Crates: A tree of modules that produces a library or executable.
~ Modules and use: Let you conntrol the organization, scope, 
  and privacy of paths.
~ Paths: A way of naming an item, such as a struct, function,
  or module.

Furthermore we will discuss scopes and encapsulation.

* Packages and Crates

  We define some useful terms:

  $ Crate
  The smallest amount of code that the Rust compiler considers
  at a time.

  Crates can contain modules, and the modules may be defined in other
  files that get compiled with the crate.

  A crate can come in two forms: a binary crate or a library crate.

  $ Binary Crate
  Programs you can compile into an executable that you can run, such 
  as a command-line program or a server. It must have a function 
  called `main` that defines what happens when the executable runs. 

  $ Library Crates
  Programs that don't have a `main` function and don't compile to an 
  executable. They define functionality intended to be shared with 
  multiple projects. 
  Conceptually, this is what is known as a library.

  For example, the `rand` crate provides functionality that 
  generates random numbers. Most of the time, when Rustaceans say 
  /crate/ they mean a library crate.

  $ Crate Root
  The source file that the Rust compiler starts from. It is the root 
  module of your crate.

  $ Package
  A bundle of one or more crates that provides a set of functionality.
  It contains a `Cargo.toml` file that describes how to build those 
  crates. 

  A package can contain as many binary crates as we like, but at 
  most only one library crate. It must contain at least one crate, 
  either library or binary.

  When we run `cargo new`



