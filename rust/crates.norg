When you write larget programs, organizing code becomes important. 

It is convenient to group code with related functionality to clarify 
what part of the code implements a certain feature.

In this section we cover Rust's /module system/: 
~ Packages: A Cargo Feature that lets you build, test, and share 
  crates.
~ Crates: A tree of modules that produces a library or executable.
~ Modules and use: Let you conntrol the organization, scope, 
  and privacy of paths.
~ Paths: A way of naming an item, such as a struct, function,
  or module.

Furthermore we will discuss scopes and encapsulation.

* Packages and Crates

  We define some useful terms:

  $ Crate
  The smallest amount of code that the Rust compiler considers
  at a time.

  Crates can contain modules, and the modules may be defined in other
  files that get compiled with the crate.

  A crate can come in two forms: a binary crate or a library crate.

  $ Binary Crate
  Programs you can compile into an executable that you can run, such 
  as a command-line program or a server. It must have a function 
  called `main` that defines what happens when the executable runs. 

  $ Library Crates
  Programs that don't have a `main` function and don't compile to an 
  executable. They define functionality intended to be shared with 
  multiple projects. 
  Conceptually, this is what is known as a library.

  For example, the `rand` crate provides functionality that 
  generates random numbers. Most of the time, when Rustaceans say 
  /crate/ they mean a library crate.

  $ Crate Root
  The source file that the Rust compiler starts from. It is the root 
  module of your crate.

  $ Package
  A bundle of one or more crates that provides a set of functionality.
  It contains a `Cargo.toml` file that describes how to build those 
  crates. 

  A package can contain as many binary crates as we like, but at 
  most only one library crate. It must contain at least one crate, 
  either library or binary.

  When we run `cargo new` and use `ls` to see what Cargo creates, we 
  see that there's a /Cargo.toml/ file, which gives us a package.

  There's also a /src/ directory that contains /main.rs/. If we open 
  /Cargo.toml/ we see there is no mention of /src/main.rs/. Cargo 
  follows a convention that /src/main.rs/ is the crate root of a 
  binary crate with the same name as the package.

  Cargo knows that if the package directory contains /src/lib.rs/, the 
  package contains a library crate with the same name as the package, 
  and /src/lib.rs/ is its crate root.

  Cargo passes the crate root files to `rustc` to build the llibrary 
  or the binary.

  If we run `cargo new my-project` then we only have a /src/main.rs/, 
  meaning it only contians a binary crate named `my-project`.
  If a package contains /src/main.rs/ and /src/lib.rs/ it has two crates: 
  a binary and a library, both with the same name as the package.

  A package can have multiple binary crates by placing files in the 
  /src/bin/ directory: each file will be a separate binary crate.

  For example, suppose that we have the following structure for the 
  package `foobar`.

  - foobar
  --- Cargo.toml
  --- build.rs
  --- src/
  ------ main.rs
  ------ util.rs
  ------ lib.rs
  ------ bin/
  --------- alt.rs
            The package

  This package contains 3 crates. 
  ~ main.rs: produces a binary crate  
  ~ lib.rs: produces a library crate 
  ~ bin/alt.rs: produces a binary crate

  The `util.rs` would be presumably used as a module within one of 
  these crates, but it is not a special filename recognized by Rust.
  So it would not be its own crate. `build.rs` is a build script.

* Defining Modules to Control Scope and Privacy

  Now we talk about modules and other parts of the module system: 
  - /paths/ that allow you to name items
  - the `use` keyword that brings a path into scope 
  - the `pub` keyword to make items public
  - the `as` keyword
  - external packages
  - the `glob` operator

  First we list some rules for easy reference:
  ~ *Start from the crate root*: The compiler first looks in the crate 
    root file (/src/lib.rs/ for a library crate or /src/main.rs/ for 
    a binary crate) for code to compile.
  ~ *Declaring modules*: In the crate root file, we can declare new
    modules. Say you declare a /garden/ module with `mod garden;`. The 
    compiler will look for the module's code in these places.
  -- Inline, within curly brackets that replace the semicolon following 
    `mod garden`.
  -- In the file /src/garden.rs/
  -- In the file /src/garden/mod.rs/
  ~ *Declaring submodules*: In any file other than the crate root, you  
    can delcare submodules. For example, you may declare `mod vegetables;`
    in /src/garden.rs/. The compile will look for the submodule's code 
    within the directory named for the parent module in these places:
  -- Inline, following `mod vegetables` with curly brackets
  -- In the file /src/garden/vegetables/
  -- In the file /src/garden/vegetables/mod.rs
  ~ *Paths to code in modules*: Once a module is part of your crate, 
    you can refer to code in that module from anywhere else in that 
    same crate, _*as long as the privacy rules allow it*_. To do so, we use 
    the path in the code.
    For example, an `Asparagus` type in the garden vegetables module, would 
    be found at `crate::garden::vegetables::Asparagus`.
  ~ *Private vs Public*: Code within a module is *private* from its parent 
    modules by default. To make a module public, declare it with `pub mod`
    instead of `mod`. To make items within a public module public as well, 
    use `pub` before their declarations.
  ~ *The `use` keyword*: Within a scope, the `use` keyword creates 
    shortcuts to items to reduce repetition of long paths. In any scope 
    that can refer to `crate::garden::vegetables::Asparagus`, you can 
    creaate a shortcut with `use crate::garden::vegetables::Asparagus`.
    And from then on, you only need to write `Asparagus` to make use of 
    that type in the scope.

  Earlier, we mentioned that /src/main.rs/ and /src/lib.rs/ are called 
  /crate roots/. The reason for their name is that the contents of 
  either of these two files form a module named /crate/ at the root 
  of the crateâ€™s module structure, known as the module tree.

* Paths for Referring to an Item in the Module Tree
  We need a path to tell Rust where an item is in a module tree.

  It can take two forms:
  ~ An absolute path starting from the crate root. For code from an 
    external crate, it begins with the crate name. For code from the 
    current crate, it starts with `crate`.
  ~ A relative path starting from the current module and uses `self`, 
    `super`, or an identifier in the current module.

  The analogy is the same as a file system. Instead of `/` to indicate 
  the root directory, we use `crate::`. 
  And if we want to use a relative path, instead of `./module` we use 
  `module/` directly. Note that `module` must be at the same level of 
  the current module we are calling from (similar to a filesystem).

  We generally prefer to specify absolute paths.

  However, if we need to remember that in Rust all items are private 
  to parent modules by default. Items in parent modules cannot use 
  items in child modules, but items in child modules can use items 
  in their ancestor modules. Siblings modules also can access each 
  other.

  This is because child modules wrap and hide their implementation 
  details, but the child modules can see the contextin which they're 
  defined.

  Rust chose this so that hiding inner implementation details is the 
  default. This way, you know which parts of the inner code you can 
  change without breaking outer code.

  Therefore, just using the correct path may cause a compile error 
  if the function is private. To expose inner parts of a child module 
  to outer ancestor modules, we use the `pub` keyword.

** Exposing Paths with the pub Keyword

   An important concept is that making a module public with `pub`
   allows code in its ancestor modules to *refer* to it, not *access* its 
   inner code. 

   To make specific items accessible *within* a public module, 
   we need to mark them as `pub` as well.

   Therefore, a module marked as `pub` is useless if none of its inner 
   items are marked `pub`. 

   A module can access a sibling module not marked as `pub` because 
   they are siblings.

** Best Practices for Packages with a Binary and a Library

   As mentioned, a package can contain both a /src/main.rs/ binary crate 
   root as well as a /src/lib.rs/ library crate root. Both crates 
   will have the package name as default.

   The module tree should be defined in /src/lib.rs/. Then, any public 
   items can be used in the binary crate by starting paths with the  
   name of the package. The binary crate becomes a user of the library 
   crate just like a completely external crate would use the library  
   crate: it can only use the public API. 

   This helps design a good API since you are also thinking as a client 
   of the library.

** Starting Relative Paths with super

   We can construct relative paths that begin in the parent module, rather
   than the current module or the crate root, by using `super` at the 
   start of the path. 
   This is like `..` in a filesystem.

** Making Structs and Enums Public

   Using `pub` with structs and enums requires a bit of additional care. 

*** Structs

    If we use `pub` before a struct definition, we make the struct public, 
    but it's fields will still be private.
    To make the field public, we need to mark them with `pub`.

    This also holds true for struct tuples.

    We also need to mark methods inside `impl` blocks as `pub` if we 
    want them to be public.

    *_If a struct has a private field, we need to provide a public 
    associated function that constructs an instance of it._*
    Otherwise, since there is a private field we cannot access, we would 
    not be able to create an instance.
    @code rust
    mod back_of_house {
        pub struct Breakfast {
            pub toast: String,
            seasonal_fruit: String,
        }

        impl Breakfast {
            pub fn summer(toast: &str) -> Breakfast {
                Breakfast {
                    toast: String::from(toast),
                    seasonal_fruit: String::from("peaches"),
                }
            }
        }
    }

    pub fn eat_at_restaurant() {
        // Order a breakfast in the summer with Rye toast
        let mut meal = back_of_house::Breakfast::summer("Rye");
        // Change our mind about what bread we'd like
        meal.toast = String::from("Wheat");
        println!("I'd like {} toast please", meal.toast);

        // The next line won't compile if we uncomment it; we're not allowed
        // to see or modify the seasonal fruit that comes with the meal
        // meal.seasonal_fruit = String::from("blueberries");
    }
    @end

*** Enums
    If we make an enum public, all of its variants are then public.
    We only need `pub` before the `enum` keyword.
    @code rust
    mod back_of_house {
        pub enum Appetizer {
            Soup,
            Salad,
        }
    }

    pub fn eat_at_restaurant() {
        let order1 = back_of_house::Appetizer::Soup;
        let order2 = back_of_house::Appetizer::Salad;
    }
    @end
    Enums are not very useful unless their variants are public. 
    It would be annoying ot have to annotate each variant with `pub`
    in every case, so the default for enum variants is to be public.

    The last thing to discuss regarding `pub` is the keyword `use`. 
    First we discuss `use` and then how it combines with `pub`.







    ~

