A /struct/ is a custom data type that lets you group together 
and name multiple related values that make up a meaningful group.

We have already seen that one method to achieve this are *Tuples*. 
We will discuss when it is appropriate to choose one or the other.

We show how to define and instantiate structs. We also talk about 
associated functions called /methods/.

Structs and Enums are the building blocks to create new types in 
our programs to take full advantage of Rust's compile-time checking.

* Defining and Instatiating Structs
  Structs are similar to tuples in that both can hold different 
  data types. However, unlike tuples, in structs we name each 
  piece of data. This makes them more clear and flexible since we
  don't rely on the order to access the data.

  To *define* and *instantiate* a struct, we do the following: 
  @code rust 
  // we use the struct keyword and a name to define a struct
  struct User {
      // we define the name and types of the pieces of data 
      // which we call *fields*
      active: bool,
      username: String,
      email: String,
      sign_in_count: u64,
  }
  fn main() {
      // to instantiate, use the name of the struct followed by 
      // curly brackets. Inside we have key:value pairs where 
      // the key is the field name and the value is what we want to store
      // we dont have to use the same order as the definition
      let mut user1 = User {
          email: String::from("someone@example.com"),
          username: String::from("someusername123"),
          active: true,
          sign_in_count: 1,
      };
      // to access a specific value, use dot operator. 
      // if instance is mutable, we can change the value of 
      // a specific field.
      user1.email = String::from("anotheremail@example.com");
  }
  @end
  Note that to change the value of a field, the *entire* instance must 
  be mutable.
  *Rust doesnt allow us to mark only certain fields as mutable.*

  We can construct a new instance of a struct as the last expression in 
  a function body to implicitly return that new instance:
  @code rust
  fn build_user(email: String, username: String) -> User {
      User {
          active: true,
          username: username,
          email: email,
          sign_in_count: 1,
      }
  }
  @end
  It is annoying that we have to repeat the same names twice, such as 
  `email:email` and `username:username`. If we had more fields, it would 
  be cumbersome and error prone.

  Rust provides a convenient shorthand for this.

** Using The Field Init Shorthand
   Since the parameter names of the function and the struct field names 
   are _exactly_ the same in the previous snippet, we can use the 
   */field init shorthand/* to rewrite it.
   @code rust
   fn build_user(email: String, username: String) -> User {
       User {
           active: true,
           username,
           email,
           sign_in_count: 1,
       }
   }
   @end
   In this case, Rust will understand how we want to intialize the struct 
   which avoids useless repetition.

** Creating Instances from Other Instances with Struct Update Syntax
   We may want to create a new instance of a struct that includes most 
   of the values from another instance, but changes some.
   We can do this through the */struct update syntax/*.

   First we show how to do it manually:
   @code rust
   fn main() {
       let user1 = User {
           email: String::from("someone@example.com"),
           username: String::from("someusername123"),
           active: true,
           sign_in_count: 1,
       };

       let user2 = User {
           active: user1.active,
           username: user1.username,
           email: String::from("another@example.com"),
           sign_in_count: user1.sign_in_count,
       };
   }
   @end
   In this case, we create `user2` to be the same as `user1` but with 
   a different email.

   Using the struct update syntax we can do the same with less code:
   @code rust
   let user2 = User {
       // we first list the fields we want changed
       email: String::from("another@example.com"),
       // and *at the end* list the struct we wish to take 
       // the remaining values from
       ..user1
   };
   @end
   The `..user1` must come last to specify that any remaining fields 
   should get their values from the corresponding fields in `user1`. 

   Note that in both cases, we are using `=` like an assignment. 
   Since strings do not implement the `Copy` trait and we are 
   assigning the same username to both users, ownership of the 
   username is moved to `user2`. This means that `user1` is not 
   usable after this operation. 
   If we had given `user2` new string values for *both* username 
   and email, then we could safely use both, since the types of 
   `active` and `sign_in_count` implement the `Copy` trait.

** Tuple Structs
   Rust supports an intermediate type between Structs and Tuples - the 
   */tuple struct/*. 
   Tuple structs allow /naming/ of the type, but dont have field names -  
   just the types.

   They are useful when we want to give the whole tuple a name to 
   differentiate from other tuples, but dont require naming fields. 

   To define and instantiate:
   @code rust 
   // definition of two tuple structs with name Color and Point
   // As we can see, we only declare the types of the fields, not 
   // the names
   struct Color(i32, i32, i32);
   struct Point(i32, i32, i32);

   fn main() {
       // To instantiate:
       let black = Color(0, 0, 0);
       let origin = Point(0, 0, 0);
   }
   @end
   Note that `black` and `origin` are different types because they are 
   instances of different tuple structs.
   *_Each struct you define is its own type, even though the fields 
   within the struct might have the same types._*

   In this case, a function that takes a `Color` type cannot take 
   a `Point` type even though both are made up of three `i32` values.

   For all other behavior, tuple structs are similar to tuples. We 
   can destructure them into individual pieces and use a `.` operator 
   to access individual values.

** Unit-Like Structs Without Any Fields
   We can also define structs that don't have any fields. 
   They are called /*unit-like*/ structs because they behave similarly 
   to `()` - aka the unit type. 

   They are useful when you need to implement a trait on some type, 
   but don't have any data that you want to store in the type 
   itself. We will talk more about it later.

   Here is an example:
   @code rust
   // to define it, simply use the struct keyword, the name, and a 
   // semicolon. No curly brackets or parenthesis.
   struct AlwaysEqual;

   fn main() {
       // to instantiate, just use the name and a semicolon. No curly 
       // brackets or parenthesis.
       let subject = AlwaysEqual;
   }
   @end
   Imagine that later weâ€™ll implement behavior for this type such that
   every instance of AlwaysEqual is always equal to every instance of 
   any other type, perhaps to have a known result for testing purposes.

** Ownership of Struct Data
   In the `User` struct definition in the first snippet, we used the 
   owned `String` type rather than `&str` string slice type.

   This is a deliberate choice because we want the struct to own all 
   of its data and for the data to be valid as long as the entire 
   struct is valid. 

   However, it is also possible to store references to data owned by 
   something else. To do so requires the use of /lifetimes/, a Rust 
   feature that ensires that the data referenced by a struct is valid 
   for as long as the struct is. 

   This will be discusses later.

** Borrowing Fields of a Struct
   Similar to what we discusses in {:rust/ownership:# Fixing a Safe Program: Mutating Different Tuple Fields}[Different Tuple Fields],
   the borrow checker will track ownership permissions at both struct-level 
   and field-level. 

   For example, if we borrow a field `x` of a `Point` struct, then 
   both `p` and `p.x` temporarily lose their permissions, but not 
   `p.y`
   @code rust 
   fn main() {
       struct Point { x: i32, y: i32 }

       let mut p = Point { x: 0, y: 0 };
       let x = &mut p.x;
       *x += 1;
       println!("{}, {}", p.x, p.y);
   }
   @end
   However, if we try to use `p` while `p.x` is mutably borrowed, 
   we get a compile time error. 
   For example, this is not valid:
   @code rust 
   struct Point { x: i32, y: i32 }

   fn print_point(p: &Point) {
       println!("{}, {}", p.x, p.y);
   }

   fn main() {
       let mut p = Point { x: 0, y: 0 };
       let x = &mut p.x;
       print_point(&p);
       *x += 1;
   }
   @end

   In general, if you encounter an ownership error that involves a struct, 
   you should consider which fields of your structure are supposed to 
   be borrowed with which permissions.
   Be aware of the borrow checkers limitations, since rust may sometimes 
   assume more fields are borrowed than they actually are.

* An Example Program Using Structs

  To understand when we might want to use structs lets write a program 
  that calculates the area of a rectangle.

  We use single variables first and then use structs.

  @code rust 
  fn main() {
      let width1 = 30;
      let height1 = 50;

      println!(
      "The area of the rectangle is {} square pixels.",
      area(width1, height1)
  );
  }

  fn area(width: u32, height: u32) -> u32 {
      width * height
  }
  @end

  This program does what we want, but it has some pitfalls. The two 
  values are not related at all coceptually, and the `area` function 
  takes two parameters, rather than a "rectangle". 

  We can refactor with tuples:
  @code rust
  fn main() {
      let rect1 = (30, 50);

      println!(
      "The area of the rectangle is {} square pixels.",
      area(rect1)
  );
  }

  fn area(dimensions: (u32, u32)) -> u32 {
      dimensions.0 * dimensions.1
  }
  @end
  Although better, the code still has some drawbacks. There is no 
  naming and it is unclear what we are doing by simply reading.

  Furthermore, for the area, changing the order of width and heigh doesn't 
  matter, but for some other operation it may make a difference. 
  With this method we have to keep track that the first index is the width 
  and the second one is the height. If we were to change this in the 
  definition of the tuple, we would need to change it everywhere else. 
  This is very error prone. 


  We can refactor using structs:
  @code rust
  struct Rectangle {
      width: u32,
      height: u32,
  }

  fn main() {
      let rect1 = Rectangle {
          width: 30,
          height: 50,
      };

      println!(
      "The area of the rectangle is {} square pixels.",
      area(&rect1)
  );
  }

  fn area(rectangle: &Rectangle) -> u32 {
      rectangle.width * rectangle.height
  }
  @end
  Now our code is much clearer and flexible. If we were to change the 
  order of our field names, it wouldn't matter. Also, since we are 
  naming the fields, the definition of area is much clearer.

  It would be nice to be able to print an instance of `Rectangle` to be 
  able to visualize all the fields and debug our program.
  If we simply use the `println!` macro, it wont work because the 
  struct doesn't have the `std::fmt::Display` method implemented, which 
  the `println!` macro uses by default.
  All primitive types implement this method by default. 

  However the compiler error tells us to use `{:\?}` instead of `{}`.
  Putting the `:\?` specifier tells `println!` to use the `Debug` format.
  The `Debug` trait enables us to print our struct in a way that is 
  useful to see its values.

  When trying to use this, we still get an error!
  `Rectangle doesn't implement Debug`

  However, it tells us how to fix it:
  `add \#[derive(Debug)] to Rectangle or manually impl Debug for Rectangle`

  Rust does include functionality to print out debugging information, 
  but we have to explicitly ask for it. 
  To do this, we add the outer attribute `\#[derive(Debug)]` just 
  before the struct definition, as shown below:
  @code rust
  #[derive(Debug)]
  struct Rectangle {
      width: u32,
      height: u32,
  }

  fn main() {
      let rect1 = Rectangle {
          width: 30,
          height: 50,
      };

      println!("rect1 is {:?}", rect1);
  }
  @end
  Now the code with `{:\?}` compiles. It is not the prettiest, but it 
  works.

  For larger structs, it's useful to have output that is easier to read. 
  For these cases, we can use `{:\#\?}` instead of `{:\?}`.

  Another way to print out a value using the `Debug` format is to use 
  the `dbg!` macro, which takes ownerhsip of an expression (as opposed 
  to `println!` which takes a reference), prints the file and line 
  number of where that `dbg!` macro call occurs in your code along 
  with the resultant value of that expression, and returns ownership 
  of the value.

  However, the `dbg!` macro prints to `stderr` rather than `stdout` which 
  is where `println!` prints.

  Here is an example:
  @code rust
  #[derive(Debug)]
  struct Rectangle {
      width: u32,
      height: u32,
  }

  fn main() {
      let scale = 2;
      let rect1 = Rectangle {
          // print debug info for width field
          // note that since dbg! gives back ownership, 
          // the width field will get the same value 
          // as if we didnt have the dbg! call there. 
          width: dbg!(30 * scale),
          height: 50,
      };

      // on the other hand, we dont want dbg! to take ownership 
      // of rect1, otherwise it becomes unusable, so we pass a 
      // reference.
      dbg!(&rect1);
  }
  @end
  We can see that the program will print the value of the width
  and the value of the struct using the pretty printing.
  The `dbg!` macro is very useful to understand what is going on in your 
  code.

  In addition to the `Debug` trait, Rust has provided a number of 
  traits for us to use with the `derive` attribute that can add 
  useful behavior to our custom types. 

  These are discussed in Appendix C.

  We will cover how to implemetn these traits with custom behavior as 
  weel as how to create your own traits later.

  Finally, our `area` function is very specific and works *only* with 
  a `Rectangle` type. It would be nice to tie this behavior even closer 
  to the `Rectangle` type. We can do this by turning the `area` function 
  into an `area` *method* defined on our `Rectangle` type.





* Method Syntax





